/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java application project to get you started.
 * For more details take a look at the 'Building Java & JVM projects' chapter in the Gradle
 * User Manual available at https://docs.gradle.org/6.7/userguide/building_java_projects.html
 */


import ro.rosmof.deploy.ProjectVersion
import ro.rosmof.deploy.ReleaseVersionTask

plugins {
    // Apply the application plugin to add support for building a CLI application in Java.
    id 'application'
    id 'org.gretty' version '2.1.0'
    id 'groovy'
    id 'java'
}


apply plugin: 'groovy'
apply plugin: 'java'
apply plugin: 'war'


/**
 * source compatibility
 * */
sourceCompatibility = 1.8

/**
 * the jar configuration
 * */
jar {
    manifest {
        attributes 'Main-Class': 'ro.rosmof.todo.ToDoApp'
    }
}

/**
 * the source sets
 * */
sourceSets {
    main {
        java {
            srcDirs = ['src/main/java']
        }
    }
    test {
        java {
            srcDirs = ['src/test']
        }
    }
}

/**
 * repositories configuration
 * */
repositories {
    // Use JCenter for resolving dependencies.
    jcenter()
    mavenCentral()
}


/**
 * the version file
 * */
ext.versionFile = file('version.properties')

/**
 * Cu asta redenumesti un fisier din war; posibil sa fie bun pentru
 * fisiere de proprietati; oricum, cu maven nici nu visam la asa ceva
 * */
war {
    rootSpec.rename {
        name ->
            if (name.equalsIgnoreCase('other.properties')) {
                'other-new.properties'
            }
    }
}

war.dependsOn { makeReleaseVersion }

/**
 * example of copy task
 * */
task ff(type: Copy) {
    destinationDir = file("$projectDir/extra")
    from("$projectDir/src") {
        exclude "**/*.java"
    }
}

/**
 * read the external configuration from a properties
 * file and create an {@link ProjectVersion} with it
 * */
ProjectVersion readVersion() {
    if (logger.isQuietEnabled()) {
        logger.quiet "Readint the version file"
    }

    if (!versionFile.exists()) {
        throw new GradleException("Required version does not exist: $versionFile.canonicalPath")
    }

    Properties versionProps = loadProperties(versionFile)

    new ProjectVersion(versionProps.major.toInteger(),
            versionProps.minor.toInteger(),
            versionProps.release.toBoolean())
}

task loadVersion {
    project.version = readVersion()
}

task makeReleaseVersion(type: ReleaseVersionTask) {
    println 'this is make release version'
    release = version.release
    minor = version.minor
    destFile = versionFile
}

task createDistribution(type: Zip, dependsOn: makeReleaseVersion) {
    from war.outputs.files

    from(sourceSets*.allSource) {
        into 'src'
    }

    from(projectDir) {
        include versionFile.name
    }
}

task backUpReleaseDistribution(type: Copy) {
    from createDistribution.outputs.files
    into "$buildDir/backup"
}

task release(dependsOn: backUpReleaseDistribution) {
    logger.quiet 'releasing the prject...'
}

static Properties loadProperties(File propertiesFile) {
    Properties result = new Properties();
    propertiesFile.withDataInputStream {
        stream -> result.load(stream)
    }

    return result
}


jar.dependsOn(makeReleaseVersion)


gradle.taskGraph.whenReady { graph ->
    println graph.toString()

    graph.getAllTasks().each { value -> println value.name }
}

/**
 *
 * ========= * ========= * ========= * =========
 *
 * CARGO CONFIGURATION (Chapter 5)
 *
 * ========= * ========= * ========= * =========
 *
 * */
configurations {

    create('ghiran', {
        description = 'un classpath pentru ghiran'
        visible = true
        println 'asa si asa, si pe dincolo'
    })
    cargo {
        description = 'Classpath for Cargo Ant task'
        visible = true
    }
}

task deployToLocalTomcat {
    doLast {
        FileTree cargoDeps = configurations.getByName('cargo').asFileTree;
        ant.taskdef(resource: 'cargo.tasks', classpath: cargoDeps.asPath)

//        ant.cargo(containerId: 'tomcat7x', action: 'run', output: "$buildDir/output.log") {
//            configuration {
//                deployable(type: 'war', file: 'app.war')
//            }
//        }
        println 'adad'
    }
}

ext.cargoGroup = 'org.codehaus.cargo'
ext.cargoVersion = '1.8.2'
ext.cargoName = 'cargo-core-uberjar'

dependencies {

    cargo (group: cargoGroup, name:cargoName, version: cargoVersion) {
        transitive = true
    }

    cargo 'xml-apis:xml-apis:2.0.2'

    /*
    example on how to use concrete methods not syntactic sugar syntax
    * */
    project.getDependencies().add('ghiran', 'com.google.guava:guava:29.0-jre', {

    })

    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.6.2'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
    implementation 'com.google.guava:guava:29.0-jre'
    implementation group: 'org.apache.commons', name: 'commons-lang3', version: '3.1'
    implementation group: 'org.apache.commons', name: 'commons-configuration2', version: '2.7'
    implementation group: 'com.google.collections', name: 'google-collections', version: '1.0'
    implementation 'org.codehaus.groovy:groovy-all:2.4.15'
    implementation group: 'org.slf4j', name: 'slf4j-api', version: '2.0.0-alpha1'
    implementation group: 'org.apache.logging.log4j', name: 'log4j-slf4j18-impl', version: '2.13.3'


    providedCompile 'javax.servlet:servlet-api:2.5',
            'javax.servlet.jsp:jsp-api:2.1'
    runtime 'javax.servlet:jstl:1.1.2',
            'taglibs:standard:1.1.2'

}

application {
    // Define the main class for the application.
    mainClass = 'ro.rosmof.App'
}

tasks.named('test') {
    // Use junit platform for unit tests.
    useJUnitPlatform()
    
    println 'just to create a new branch, test'
}
